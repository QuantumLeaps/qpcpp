//$file${.::pelican.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: pelican.qm
// File:  ${.::pelican.cpp}
//
// This code has been generated by QM 5.2.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open source software: you can redistribute it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// NOTE:
// Alternatively, this generated code may be distributed under the terms
// of Quantum Leaps commercial licenses, which expressly supersede the GNU
// General Public License and are specifically designed for licensees
// interested in retaining the proprietary status of their code.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::pelican.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"
#include "bsp.hpp"
#include "pelican.hpp"

Q_DEFINE_THIS_FILE

// Pelican class -------------------------------------------------------------
//$declare${components::Pelican} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace PELICAN {

//${components::Pelican} .....................................................
class Pelican : public QP::GuiQActive {
private:
    QP::QTimeEvt m_timeout;
    uint8_t m_flashCtr;

public:
    Pelican()
     : GuiQActive(Q_STATE_CAST(&Pelican::initial)),
       m_timeout(this, TIMEOUT_SIG)
    {}

protected:
    Q_STATE_DECL(initial);
    Q_STATE_DECL(operational);
    Q_STATE_DECL(carsEnabled);
    Q_STATE_DECL(carsGreen);
    Q_STATE_DECL(carsGreenNoPed);
    Q_STATE_DECL(carsGreenInt);
    Q_STATE_DECL(carsGreenPedWait);
    Q_STATE_DECL(carsYellow);
    Q_STATE_DECL(pedsEnabled);
    Q_STATE_DECL(pedsWalk);
    Q_STATE_DECL(pedsFlash);
    Q_STATE_DECL(offline);
}; // class Pelican

} // namespace PELICAN
//$enddecl${components::Pelican} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

namespace PELICAN {

enum PelicanTimeouts {  // various timeouts in ticks
    CARS_GREEN_MIN_TOUT = BSP_TICKS_PER_SEC * 8, // min green for cars
    CARS_YELLOW_TOUT = BSP_TICKS_PER_SEC * 3,  // yellow for cars
    PEDS_WALK_TOUT   = BSP_TICKS_PER_SEC * 3,  // walking time for peds
    PEDS_FLASH_TOUT  = BSP_TICKS_PER_SEC / 5,  // flashing timeout for peds
    PEDS_FLASH_NUM   = 5*2,                    // number of flashes for peds
    OFF_FLASH_TOUT   = BSP_TICKS_PER_SEC / 2   // flashing timeout when off
};

// Local objects -------------------------------------------------------------
static Pelican l_Pelican; // the single instance of Pelican active object

// Global objects ------------------------------------------------------------
QP::QActive * const AO_Pelican = &l_Pelican; // the opaque pointer

} // namespace PELICAN

// Pelican class definition --------------------------------------------------
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 6.9.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${components::Pelican} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace PELICAN {

//${components::Pelican} .....................................................

//${components::Pelican::SM} .................................................
Q_STATE_DEF(Pelican, initial) {
    //${components::Pelican::SM::initial}
    subscribe(PEDS_WAITING_SIG);
    subscribe(TERMINATE_SIG);

    QS_OBJ_DICTIONARY(&l_Pelican);
    QS_OBJ_DICTIONARY(&l_Pelican.m_timeout);

    QS_FUN_DICTIONARY(&QP::QHsm::top);
    QS_FUN_DICTIONARY(&Pelican::initial);
    QS_FUN_DICTIONARY(&Pelican::offline);
    QS_FUN_DICTIONARY(&Pelican::operational);
    QS_FUN_DICTIONARY(&Pelican::carsEnabled);
    QS_FUN_DICTIONARY(&Pelican::carsGreen);
    QS_FUN_DICTIONARY(&Pelican::carsGreenNoPed);
    QS_FUN_DICTIONARY(&Pelican::carsGreenPedWait);
    QS_FUN_DICTIONARY(&Pelican::carsGreenInt);
    QS_FUN_DICTIONARY(&Pelican::carsYellow);
    QS_FUN_DICTIONARY(&Pelican::pedsEnabled);
    QS_FUN_DICTIONARY(&Pelican::pedsWalk);
    QS_FUN_DICTIONARY(&Pelican::pedsFlash);

    QS_SIG_DICTIONARY(PEDS_WAITING_SIG, nullptr);  // global signals
    QS_SIG_DICTIONARY(ON_SIG,           nullptr);
    QS_SIG_DICTIONARY(OFF_SIG,          nullptr);

    QS_SIG_DICTIONARY(TIMEOUT_SIG,      &l_Pelican); // just for Pelican

    (void)e; // unused parameter

    QS_FUN_DICTIONARY(&Pelican::operational);
    QS_FUN_DICTIONARY(&Pelican::carsEnabled);
    QS_FUN_DICTIONARY(&Pelican::carsGreen);
    QS_FUN_DICTIONARY(&Pelican::carsGreenNoPed);
    QS_FUN_DICTIONARY(&Pelican::carsGreenInt);
    QS_FUN_DICTIONARY(&Pelican::carsGreenPedWait);
    QS_FUN_DICTIONARY(&Pelican::carsYellow);
    QS_FUN_DICTIONARY(&Pelican::pedsEnabled);
    QS_FUN_DICTIONARY(&Pelican::pedsWalk);
    QS_FUN_DICTIONARY(&Pelican::pedsFlash);
    QS_FUN_DICTIONARY(&Pelican::offline);

    return tran(&operational);
}

//${components::Pelican::SM::operational} ....................................
Q_STATE_DEF(Pelican, operational) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational}
        case Q_ENTRY_SIG: {
            BSP_signalCars(CARS_RED);
            BSP_signalPeds(PEDS_DONT_WALK);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::initial}
        case Q_INIT_SIG: {
            status_ = tran(&carsEnabled);
            break;
        }
        //${components::Pelican::SM::operational::OFF}
        case OFF_SIG: {
            status_ = tran(&offline);
            break;
        }
        //${components::Pelican::SM::operational::TERMINATE}
        case TERMINATE_SIG: {
            BSP_terminate(0);
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::carsEnabled} .......................
Q_STATE_DEF(Pelican, carsEnabled) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::carsEnabled}
        case Q_EXIT_SIG: {
            BSP_signalCars(CARS_RED);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::initial}
        case Q_INIT_SIG: {
            status_ = tran(&carsGreen);
            break;
        }
        default: {
            status_ = super(&operational);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::carsEnabled::carsGreen} ............
Q_STATE_DEF(Pelican, carsGreen) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::carsEnabled::carsGreen}
        case Q_ENTRY_SIG: {
            BSP_signalCars(CARS_GREEN);
            m_timeout.armX(CARS_GREEN_MIN_TOUT);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::carsGreen}
        case Q_EXIT_SIG: {
            (void)m_timeout.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::carsGreen::initial}
        case Q_INIT_SIG: {
            status_ = tran(&carsGreenNoPed);
            break;
        }
        default: {
            status_ = super(&carsEnabled);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenNoPed}
Q_STATE_DEF(Pelican, carsGreenNoPed) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenNoPed}
        case Q_ENTRY_SIG: {
            BSP_showState("carsGreenNoPed");
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenNoPed::PEDS_WAITING}
        case PEDS_WAITING_SIG: {
            status_ = tran(&carsGreenPedWait);
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenNoPed::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&carsGreenInt);
            break;
        }
        default: {
            status_ = super(&carsGreen);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenInt}
Q_STATE_DEF(Pelican, carsGreenInt) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenInt}
        case Q_ENTRY_SIG: {
            BSP_showState("carsGreenInt");
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenInt::PEDS_WAITING}
        case PEDS_WAITING_SIG: {
            status_ = tran(&carsYellow);
            break;
        }
        default: {
            status_ = super(&carsGreen);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenPedWait}
Q_STATE_DEF(Pelican, carsGreenPedWait) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenPedWait}
        case Q_ENTRY_SIG: {
            BSP_showState("carsGreenPedWait");
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::carsGreen::carsGreenPedWait::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&carsYellow);
            break;
        }
        default: {
            status_ = super(&carsGreen);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::carsEnabled::carsYellow} ...........
Q_STATE_DEF(Pelican, carsYellow) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::carsEnabled::carsYellow}
        case Q_ENTRY_SIG: {
            BSP_showState("carsYellow");
            BSP_signalCars(CARS_YELLOW);
            m_timeout.armX(CARS_YELLOW_TOUT);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::carsYellow}
        case Q_EXIT_SIG: {
            (void)m_timeout.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::carsEnabled::carsYellow::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&pedsEnabled);
            break;
        }
        default: {
            status_ = super(&carsEnabled);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::pedsEnabled} .......................
Q_STATE_DEF(Pelican, pedsEnabled) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::pedsEnabled}
        case Q_EXIT_SIG: {
            BSP_signalPeds(PEDS_DONT_WALK);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::pedsEnabled::initial}
        case Q_INIT_SIG: {
            status_ = tran(&pedsWalk);
            break;
        }
        default: {
            status_ = super(&operational);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::pedsEnabled::pedsWalk} .............
Q_STATE_DEF(Pelican, pedsWalk) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::pedsEnabled::pedsWalk}
        case Q_ENTRY_SIG: {
            BSP_showState("pedsWalk");
            BSP_signalPeds(PEDS_WALK);
            m_timeout.armX(PEDS_WALK_TOUT);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::pedsEnabled::pedsWalk}
        case Q_EXIT_SIG: {
            (void)m_timeout.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::pedsEnabled::pedsWalk::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&pedsFlash);
            break;
        }
        default: {
            status_ = super(&pedsEnabled);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::operational::pedsEnabled::pedsFlash} ............
Q_STATE_DEF(Pelican, pedsFlash) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::operational::pedsEnabled::pedsFlash}
        case Q_ENTRY_SIG: {
            BSP_showState("pedsFlash");
            m_timeout.armX(PEDS_FLASH_TOUT, PEDS_FLASH_TOUT);
            m_flashCtr = PEDS_FLASH_NUM*2 + 1;
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::pedsEnabled::pedsFlash}
        case Q_EXIT_SIG: {
            (void)m_timeout.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::operational::pedsEnabled::pedsFlash::TIMEOUT}
        case TIMEOUT_SIG: {
            //${components::Pelican::SM::operational::pedsEnabled::pedsFlash::TIMEOUT::[m_flashCtr!=0U]}
            if (m_flashCtr != 0U) {
                --m_flashCtr;
                //${components::Pelican::SM::operational::pedsEnabled::pedsFlash::TIMEOUT::[m_flashCtr!=0U]::[(m_flashCtr&1U)==0U]}
                if ((m_flashCtr & 1U) == 0U) {
                    BSP_signalPeds(PEDS_DONT_WALK);
                    status_ = Q_RET_HANDLED;
                }
                //${components::Pelican::SM::operational::pedsEnabled::pedsFlash::TIMEOUT::[m_flashCtr!=0U]::[else]}
                else {
                    BSP_signalPeds(PEDS_BLANK);
                    status_ = Q_RET_HANDLED;
                }
            }
            //${components::Pelican::SM::operational::pedsEnabled::pedsFlash::TIMEOUT::[else]}
            else {
                status_ = tran(&carsEnabled);
            }
            break;
        }
        default: {
            status_ = super(&pedsEnabled);
            break;
        }
    }
    return status_;
}

//${components::Pelican::SM::offline} ........................................
Q_STATE_DEF(Pelican, offline) {
    QP::QState status_;
    switch (e->sig) {
        //${components::Pelican::SM::offline}
        case Q_ENTRY_SIG: {
            BSP_showState("offline");
            m_timeout.armX(OFF_FLASH_TOUT, OFF_FLASH_TOUT);
            m_flashCtr = 0U;
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::offline}
        case Q_EXIT_SIG: {
            (void)m_timeout.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${components::Pelican::SM::offline::TIMEOUT}
        case TIMEOUT_SIG: {
            m_flashCtr ^= 1U;
            //${components::Pelican::SM::offline::TIMEOUT::[(m_flashCtr&1U)==0U]}
            if ((m_flashCtr & 1U) == 0U) {
                BSP_signalCars(CARS_RED);
                BSP_signalPeds(PEDS_DONT_WALK);
                status_ = Q_RET_HANDLED;
            }
            //${components::Pelican::SM::offline::TIMEOUT::[else]}
            else {
                BSP_signalCars(CARS_BLANK);
                BSP_signalPeds(PEDS_BLANK);
                status_ = Q_RET_HANDLED;
            }
            break;
        }
        //${components::Pelican::SM::offline::ON}
        case ON_SIG: {
            status_ = tran(&operational);
            break;
        }
        //${components::Pelican::SM::offline::TERMINATE}
        case TERMINATE_SIG: {
            BSP_terminate(0);
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

} // namespace PELICAN
//$enddef${components::Pelican} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
